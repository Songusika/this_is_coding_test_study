## 🧐 문제 해석
> 보유하고 있는 화폐단위를 가지고 많들 수 없는 금액의 최솟값을 찾아라

보유하고 있는 화폐가 3원, 2원, 1원, 1원, 9원이라면

1원은 이미 1원이 있기 때문에 최소가 아니며, 2원은 2원과 혹은 1원 2개를 합쳐서 만들어지기 때문에 최소가 아니다.

3원 또한 3원이 이미 있으며, 2원과 1원을 합쳐서 만들어지기 때문에 최소가 아니다.

4원 또한 2원과 1원 2개를 합쳐서 만들어질 수 있으므로 최소가 아니다.

계속 진행...

**8원은 보유하고 있는 화폐를 가지고 만들 수 없기 때문에 최소값이 된다.**

## 🤔 문제 접근
어떻게 하면 가장 최소 화폐를 만들 수 있을까?

방법 1: **최소 금액부터 주어진 화폐로 조합이 가능한지 검사하며 진행한다.**

8원이 최소 금액인지 검사하고 싶을 경우, 주어진 화폐에 8원이 있다면 다음 9원 검사, 없으면 아래의 검사를 진행

1. 8원보다 작은 금액을 뽑아 배열/리스트에 담는다. ex) 3원, 2원, 1원, 1원, 9원
    + [3, 2, 1, 1]

2. 해당 리스트에서 8원이 조합가능한지 검사한다.
    + 조합 가능한 금액: 1원, 2원, 3원, 4원, 5원, 6원, 7원, 8원

3. 해당 리스트에서 8원이 조합 불가능하기 때문에 8원이 최소금액이다.


방법 2: **주어진 화폐로 만들 수 있는 모든 화폐를 만들고 거기서 최소값을 찾는다**


1. 주어진 화폐로 모든 조합을 미리 계산한다. ex) 5원 2원 1원 1원
    + 1원, 2원(2원, 1원+1원), 3원(2원+1원), 4원(2원+1원+1원), 5원, 6원(5원+1원), 7원(5원+2원, 5원+1원+1원), 8원(5원+2원+1원), 9원(5원+2원+1원+1원)

2. 해당 조합 결과에서 0을 제외한 양수 최소값을 찾는다.
    +  정답은 **10원**이다.

조합이 가능한 금액을 넣을 리스트를 만들고, 가능한 조합 금액을 중복을 제외하고 추가하자

이후 해당 리스트를 통해서 최소의 금액을 찾자.

ex) possibleCoinList = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16] &rarr; 8원

+ 방법 2로 풀기로 결정 &rarr; 두 방법 모두 너무 많은 시간복잡도를 요구 방법 3 생각

방법 3: **오름차순 정렬 후 작은 금액부터 하나씩 만들자**

만들 수 없는 최소값이므로 만들 수 있는 최소값 + 1 을 반환하면 된다.

즉, 오름차순으로 정렬 후 작은 금액을 만들면서 만들 수 있는 금액인지 검사 하며 타깃값(원하는 만들 수 없는 최소 금액)을 업데이트하자.

검사는 현재 타깃값이 현재 인덱스에 저장된 값보다 크거나 같다면(currentMoney <= targetMoney),

이전 인덱스들과 저장된 금액과 현재 인덱스에 저장된 값들로 (1 ~ 업데이트 될 타깃값-1)을 만들 수 있다.

그러다면 현재 인덱스에 저장된 값과 현재 타깃값을 더하여 타깃값을 업데이트하고 다음번 인덱스를 검사한다.

현재 타깃값보다 현재 인덱스에 저장된 값이 크다면(currentMoney > targetMoney) 현재 타깃값은 만들 수 없는 최소 금액이 된다.

왜냐하면 타깃값보다 큰 값을 통해서는 어떤 값을 더해서도 타깃값을 만들 수 없기 때문이다.

1. 가장 적은 타깃값은 1이므로 1로 초기화 한다.

2. 현재 인덱스에 저장된 값이 현재 타깃값보다 크다면
    + 현재 타깃값이 만들 수 없는 가장 작은 값이다.

3. 현재 인덱스에 저장된 값이 타깃값보다 작거나 같다면
    + 현재 타깃값은 만들 수 있는 금액이다.
    + 따라서 타깃값을 조정한다. &rarr; 현재 타깃값에 현재 인덱스 값을 더한다.


이 방법에서 중요한 점은 오름차순으로 정렬해서 가장 작은 금액 부터 검사해 가는 것



**방법 3이 여기선 제일 좋지만 한번 조합 함수를 만들어 보는 것도 좋은 경험이었을 것 같다.**

## 📚 기능 목록
+ 주어진 입력값을 검증하는 기능
    + 1<= N <= 1,000?
    + 화폐 단위가 1,000,000 이하의 자연수인가?
+ 주어진 화폐를 리스트에 추가하는 기능
    + 오름차순으로 정렬하여 저장
+ 만들 수 없는 최소 금액을 반환 하는 기능
